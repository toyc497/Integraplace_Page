import { booleanAttribute, computed, Directive, effect, ElementRef, inject, Input, numberAttribute, Renderer2, signal } from '@angular/core';
import * as i0 from "@angular/core";
export class ProgressBarDirective {
    constructor() {
        this.#renderer = inject(Renderer2);
        this.#hostElement = inject(ElementRef);
        this.#max = signal(100);
        this.#min = 0;
        this.#value = signal(undefined);
        this.#width = signal(undefined);
        this.percent = computed(() => {
            return +((((this.#value() ?? this.#width() ?? 0) - this.#min) / (this.#max() - this.#min)) * 100).toFixed(this.precision);
        });
        this.#valuesEffect = effect(() => {
            const host = this.#hostElement.nativeElement;
            if (this.#value() === undefined || this.#width()) {
                for (let name of ['aria-valuenow', 'aria-valuemax', 'aria-valuemin', 'role']) {
                    this.#renderer.removeAttribute(host, name);
                }
            }
            else {
                this.#renderer.setAttribute(host, 'aria-valuenow', String(this.#value()));
                this.#renderer.setAttribute(host, 'aria-valuemin', String(this.#min));
                this.#renderer.setAttribute(host, 'aria-valuemax', String(this.#max()));
                this.#renderer.setAttribute(host, 'role', this.role);
            }
            const tagName = host.tagName;
            if (this.percent() && ((this.stacked && tagName === 'C-PROGRESS') || (!this.stacked && tagName !== 'C-PROGRESS'))) {
                this.#renderer.setStyle(host, 'width', `${this.percent()}%`);
            }
            else {
                this.#renderer.removeStyle(host, 'width');
            }
        });
        // TODO: check if this is necessary.
        this.precision = 0;
        /**
         * Stacked ProgressBars.
         * @type boolean
         * @default false
         */
        this.stacked = false;
        /**
         * Set default html role attribute.
         * @type string
         */
        this.role = 'progressbar';
    }
    #renderer;
    #hostElement;
    #max;
    #min;
    #value;
    #width;
    #valuesEffect;
    /**
     * The percent value the ProgressBar.
     * @type number
     * @default 0
     */
    set value(value) {
        this.#value.set(value);
    }
    get value() {
        return this.#value();
    }
    set width(value) {
        this.#width.set(value);
    }
    /**
     * The max value of the ProgressBar.
     * @type number
     * @default 100
     */
    set max(max) {
        this.#max.set(isNaN(max) || max <= 0 ? 100 : max);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: ProgressBarDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "16.1.0", version: "17.3.12", type: ProgressBarDirective, isStandalone: true, selector: "[cProgressBar]", inputs: { animated: ["animated", "animated", booleanAttribute], color: "color", precision: ["precision", "precision", numberAttribute], value: ["value", "value", numberAttribute], width: ["width", "width", numberAttribute], variant: "variant", max: ["max", "max", numberAttribute], stacked: ["stacked", "stacked", booleanAttribute], role: "role" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: ProgressBarDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cProgressBar]',
                    standalone: true
                }]
        }], ctorParameters: () => [], propDecorators: { animated: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], color: [{
                type: Input
            }], precision: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], value: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], width: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], variant: [{
                type: Input
            }], max: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], stacked: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], role: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZ3Jlc3MtYmFyLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2NvcmV1aS1hbmd1bGFyL3NyYy9saWIvcHJvZ3Jlc3MvcHJvZ3Jlc3MtYmFyLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsZ0JBQWdCLEVBQ2hCLFFBQVEsRUFDUixTQUFTLEVBQ1QsTUFBTSxFQUVOLFVBQVUsRUFDVixNQUFNLEVBQ04sS0FBSyxFQUNMLGVBQWUsRUFDZixTQUFTLEVBQ1QsTUFBTSxFQUVQLE1BQU0sZUFBZSxDQUFDOztBQVF2QixNQUFNLE9BQU8sb0JBQW9CO0lBRS9CO1FBRVMsY0FBUyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUM5QixpQkFBWSxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUVsQyxTQUFJLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ25CLFNBQUksR0FBRyxDQUFDLENBQUM7UUFDVCxXQUFNLEdBQXVDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUMvRCxXQUFNLEdBQXVDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUUvRCxZQUFPLEdBQUcsUUFBUSxDQUFDLEdBQUcsRUFBRTtZQUMvQixPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQzVILENBQUMsQ0FBQyxDQUFDO1FBRU0sa0JBQWEsR0FBYyxNQUFNLENBQUMsR0FB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cEIsb0JBQW9CLCtGQXdDWCxnQkFBZ0IseURBU2hCLGVBQWUsNkJBT2YsZUFBZSw2QkFTZixlQUFlLDJDQWlCZixlQUFlLG1DQVVmLGdCQUFnQjs7NEZBNUZ6QixvQkFBb0I7a0JBSmhDLFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLGdCQUFnQjtvQkFDMUIsVUFBVSxFQUFFLElBQUk7aUJBQ2pCO3dEQXlDeUMsUUFBUTtzQkFBL0MsS0FBSzt1QkFBQyxFQUFFLFNBQVMsRUFBRSxnQkFBZ0IsRUFBRTtnQkFNN0IsS0FBSztzQkFBYixLQUFLO2dCQUdpQyxTQUFTO3NCQUEvQyxLQUFLO3VCQUFDLEVBQUUsU0FBUyxFQUFFLGVBQWUsRUFBRTtnQkFRakMsS0FBSztzQkFEUixLQUFLO3VCQUFDLEVBQUUsU0FBUyxFQUFFLGVBQWUsRUFBRTtnQkFVakMsS0FBSztzQkFEUixLQUFLO3VCQUFDLEVBQUUsU0FBUyxFQUFFLGVBQWUsRUFBRTtnQkFVNUIsT0FBTztzQkFBZixLQUFLO2dCQVFGLEdBQUc7c0JBRE4sS0FBSzt1QkFBQyxFQUFFLFNBQVMsRUFBRSxlQUFlLEVBQUU7Z0JBVUcsT0FBTztzQkFBOUMsS0FBSzt1QkFBQyxFQUFFLFNBQVMsRUFBRSxnQkFBZ0IsRUFBRTtnQkFNN0IsSUFBSTtzQkFBWixLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgYm9vbGVhbkF0dHJpYnV0ZSxcbiAgY29tcHV0ZWQsXG4gIERpcmVjdGl2ZSxcbiAgZWZmZWN0LFxuICBFZmZlY3RSZWYsXG4gIEVsZW1lbnRSZWYsXG4gIGluamVjdCxcbiAgSW5wdXQsXG4gIG51bWJlckF0dHJpYnV0ZSxcbiAgUmVuZGVyZXIyLFxuICBzaWduYWwsXG4gIFdyaXRhYmxlU2lnbmFsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29sb3JzIH0gZnJvbSAnLi4vY29yZXVpLnR5cGVzJztcbmltcG9ydCB7IElQcm9ncmVzc0JhciB9IGZyb20gJy4vcHJvZ3Jlc3MudHlwZSc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tjUHJvZ3Jlc3NCYXJdJyxcbiAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBQcm9ncmVzc0JhckRpcmVjdGl2ZSBpbXBsZW1lbnRzIElQcm9ncmVzc0JhciB7XG5cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIHJlYWRvbmx5ICNyZW5kZXJlciA9IGluamVjdChSZW5kZXJlcjIpO1xuICByZWFkb25seSAjaG9zdEVsZW1lbnQgPSBpbmplY3QoRWxlbWVudFJlZik7XG5cbiAgcmVhZG9ubHkgI21heCA9IHNpZ25hbCgxMDApO1xuICByZWFkb25seSAjbWluID0gMDtcbiAgcmVhZG9ubHkgI3ZhbHVlOiBXcml0YWJsZVNpZ25hbDxudW1iZXIgfCB1bmRlZmluZWQ+ID0gc2lnbmFsKHVuZGVmaW5lZCk7XG4gIHJlYWRvbmx5ICN3aWR0aDogV3JpdGFibGVTaWduYWw8bnVtYmVyIHwgdW5kZWZpbmVkPiA9IHNpZ25hbCh1bmRlZmluZWQpO1xuXG4gIHJlYWRvbmx5IHBlcmNlbnQgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgcmV0dXJuICsoKCgodGhpcy4jdmFsdWUoKSA/PyB0aGlzLiN3aWR0aCgpID8/IDApIC0gdGhpcy4jbWluKSAvICh0aGlzLiNtYXgoKSAtIHRoaXMuI21pbikpICogMTAwKS50b0ZpeGVkKHRoaXMucHJlY2lzaW9uKTtcbiAgfSk7XG5cbiAgcmVhZG9ubHkgI3ZhbHVlc0VmZmVjdDogRWZmZWN0UmVmID0gZWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBob3N0OiBIVE1MRWxlbWVudCA9IHRoaXMuI2hvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKHRoaXMuI3ZhbHVlKCkgPT09IHVuZGVmaW5lZCB8fCB0aGlzLiN3aWR0aCgpKSB7XG4gICAgICBmb3IgKGxldCBuYW1lIG9mIFsnYXJpYS12YWx1ZW5vdycsICdhcmlhLXZhbHVlbWF4JywgJ2FyaWEtdmFsdWVtaW4nLCAncm9sZSddKSB7XG4gICAgICAgIHRoaXMuI3JlbmRlcmVyLnJlbW92ZUF0dHJpYnV0ZShob3N0LCBuYW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jcmVuZGVyZXIuc2V0QXR0cmlidXRlKGhvc3QsICdhcmlhLXZhbHVlbm93JywgU3RyaW5nKHRoaXMuI3ZhbHVlKCkpKTtcbiAgICAgIHRoaXMuI3JlbmRlcmVyLnNldEF0dHJpYnV0ZShob3N0LCAnYXJpYS12YWx1ZW1pbicsIFN0cmluZyh0aGlzLiNtaW4pKTtcbiAgICAgIHRoaXMuI3JlbmRlcmVyLnNldEF0dHJpYnV0ZShob3N0LCAnYXJpYS12YWx1ZW1heCcsIFN0cmluZyh0aGlzLiNtYXgoKSkpO1xuICAgICAgdGhpcy4jcmVuZGVyZXIuc2V0QXR0cmlidXRlKGhvc3QsICdyb2xlJywgdGhpcy5yb2xlKTtcbiAgICB9XG4gICAgY29uc3QgdGFnTmFtZSA9IGhvc3QudGFnTmFtZTtcbiAgICBpZiAodGhpcy5wZXJjZW50KCkgJiYgKCh0aGlzLnN0YWNrZWQgJiYgdGFnTmFtZSA9PT0gJ0MtUFJPR1JFU1MnKSB8fCAoIXRoaXMuc3RhY2tlZCAmJiB0YWdOYW1lICE9PSAnQy1QUk9HUkVTUycpKSkge1xuICAgICAgdGhpcy4jcmVuZGVyZXIuc2V0U3R5bGUoaG9zdCwgJ3dpZHRoJywgYCR7dGhpcy5wZXJjZW50KCl9JWApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNyZW5kZXJlci5yZW1vdmVTdHlsZShob3N0LCAnd2lkdGgnKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBVc2UgdG8gYW5pbWF0ZSB0aGUgc3RyaXBlcyByaWdodCB0byBsZWZ0IHZpYSBDU1MzIGFuaW1hdGlvbnMuXG4gICAqIEB0eXBlIGJvb2xlYW5cbiAgICovXG4gIEBJbnB1dCh7IHRyYW5zZm9ybTogYm9vbGVhbkF0dHJpYnV0ZSB9KSBhbmltYXRlZD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNvbG9yIGNvbnRleHQgb2YgdGhlIGNvbXBvbmVudCB0byBvbmUgb2YgQ29yZVVJ4oCZcyB0aGVtZWQgY29sb3JzLlxuICAgKiBAdmFsdWVzICdwcmltYXJ5JywgJ3NlY29uZGFyeScsICdzdWNjZXNzJywgJ2RhbmdlcicsICd3YXJuaW5nJywgJ2luZm8nLCAnZGFyaycsICdsaWdodCdcbiAgICovXG4gIEBJbnB1dCgpIGNvbG9yPzogQ29sb3JzO1xuXG4gIC8vIFRPRE86IGNoZWNrIGlmIHRoaXMgaXMgbmVjZXNzYXJ5LlxuICBASW5wdXQoeyB0cmFuc2Zvcm06IG51bWJlckF0dHJpYnV0ZSB9KSBwcmVjaXNpb246IG51bWJlciA9IDA7XG5cbiAgLyoqXG4gICAqIFRoZSBwZXJjZW50IHZhbHVlIHRoZSBQcm9ncmVzc0Jhci5cbiAgICogQHR5cGUgbnVtYmVyXG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIEBJbnB1dCh7IHRyYW5zZm9ybTogbnVtYmVyQXR0cmlidXRlIH0pXG4gIHNldCB2YWx1ZSh2YWx1ZTogbnVtYmVyIHwgdW5kZWZpbmVkKSB7XG4gICAgdGhpcy4jdmFsdWUuc2V0KHZhbHVlKTtcbiAgfVxuXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jdmFsdWUoKTtcbiAgfVxuXG4gIEBJbnB1dCh7IHRyYW5zZm9ybTogbnVtYmVyQXR0cmlidXRlIH0pXG4gIHNldCB3aWR0aCh2YWx1ZTogbnVtYmVyIHwgdW5kZWZpbmVkKSB7XG4gICAgdGhpcy4jd2lkdGguc2V0KHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHByb2dyZXNzIGJhciB2YXJpYW50IHRvIG9wdGlvbmFsIHN0cmlwZWQuXG4gICAqIEB2YWx1ZXMgJ3N0cmlwZWQnXG4gICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgKi9cbiAgQElucHV0KCkgdmFyaWFudD86ICdzdHJpcGVkJztcblxuICAvKipcbiAgICogVGhlIG1heCB2YWx1ZSBvZiB0aGUgUHJvZ3Jlc3NCYXIuXG4gICAqIEB0eXBlIG51bWJlclxuICAgKiBAZGVmYXVsdCAxMDBcbiAgICovXG4gIEBJbnB1dCh7IHRyYW5zZm9ybTogbnVtYmVyQXR0cmlidXRlIH0pXG4gIHNldCBtYXgobWF4OiBudW1iZXIpIHtcbiAgICB0aGlzLiNtYXguc2V0KGlzTmFOKG1heCkgfHwgbWF4IDw9IDAgPyAxMDAgOiBtYXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YWNrZWQgUHJvZ3Jlc3NCYXJzLlxuICAgKiBAdHlwZSBib29sZWFuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBASW5wdXQoeyB0cmFuc2Zvcm06IGJvb2xlYW5BdHRyaWJ1dGUgfSkgc3RhY2tlZD86IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKipcbiAgICogU2V0IGRlZmF1bHQgaHRtbCByb2xlIGF0dHJpYnV0ZS5cbiAgICogQHR5cGUgc3RyaW5nXG4gICAqL1xuICBASW5wdXQoKSByb2xlOiBzdHJpbmcgPSAncHJvZ3Jlc3NiYXInO1xuXG59XG4iXX0=