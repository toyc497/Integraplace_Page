import { Component, DestroyRef, EventEmitter, HostBinding, inject, Inject, Input, Output } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { fromEvent } from 'rxjs';
import { filter, finalize, withLatestFrom, zipWith } from 'rxjs/operators';
import { ListenersService } from '../../services';
import { ThemeDirective } from '../../shared/theme.directive';
import { CarouselState } from '../carousel-state';
import { CarouselService } from '../carousel.service';
import { CarouselConfig } from '../carousel.config';
import * as i0 from "@angular/core";
import * as i1 from "../carousel.service";
import * as i2 from "../carousel-state";
import * as i3 from "../../services";
import * as i4 from "../../shared/theme.directive";
import * as i5 from "../carousel.config";
export class CarouselComponent {
    constructor(config, hostElement, carouselService, carouselState, intersectionService, listenersService) {
        this.config = config;
        this.hostElement = hostElement;
        this.carouselService = carouselService;
        this.carouselState = carouselState;
        this.intersectionService = intersectionService;
        this.listenersService = listenersService;
        /**
         * Index of the active item.
         * @type number
         */
        this.activeIndex = 0;
        /**
         * Carousel automatically starts cycle items.
         * @type boolean
         */
        this.animate = true;
        /**
         * Carousel direction. [docs]
         * @type {'next' | 'prev'}
         */
        this.direction = 'next';
        /**
         * The amount of time to delay between automatically cycling an item. If false, carousel will not automatically cycle.
         * @type number
         * @default 0
         */
        this.interval = 0;
        /**
         * Sets which event handlers you’d like provided to your pause prop. You can specify one trigger or an array of them.
         * @type {'hover' | 'focus' | 'click'}
         */
        this.pause = 'hover';
        /**
         * Support left/right swipe interactions on touchscreen devices.
         * @type boolean
         * @default true
         */
        this.touch = true;
        /**
         * Set type of the transition.
         * @type {'slide' | 'crossfade'}
         * @default 'slide'
         */
        this.transition = 'slide';
        /**
         * Set whether the carousel should cycle continuously or have hard stops.
         * @type boolean
         * @default true
         */
        this.wrap = true;
        /**
         * Event emitted on carousel item change. [docs]
         * @type number
         */
        this.itemChange = new EventEmitter();
        this.activeItemInterval = 0;
        this.#destroyRef = inject(DestroyRef);
        this._visible = true;
        Object.assign(this, config);
    }
    get hostClasses() {
        return {
            carousel: true,
            slide: true,
            'carousel-fade': this.transition === 'crossfade'
        };
    }
    #destroyRef;
    ngOnInit() {
        this.carouselStateSubscribe();
    }
    ngOnDestroy() {
        this.resetTimer();
        this.clearListeners();
        this.swipeSubscribe(false);
    }
    ngAfterContentInit() {
        this.intersectionServiceSubscribe();
        this.carouselState.state = { activeItemIndex: this.activeIndex, animate: this.animate };
        this.setListeners();
        this.swipeSubscribe();
    }
    setListeners() {
        const config = {
            hostElement: this.hostElement,
            trigger: this.pause || [],
            callbackOff: () => {
                this.setTimer();
            },
            callbackOn: () => {
                this.resetTimer();
            }
        };
        this.listenersService.setListeners(config);
    }
    clearListeners() {
        this.listenersService.clearListeners();
    }
    set visible(value) {
        this._visible = value;
    }
    get visible() {
        return this._visible;
    }
    setTimer() {
        const interval = this.activeItemInterval || 0;
        this.resetTimer();
        if (interval > 0) {
            this.timerId = setTimeout(() => {
                const nextIndex = this.carouselState.direction(this.direction);
                this.carouselState.state = { activeItemIndex: nextIndex };
            }, interval);
        }
    }
    resetTimer() {
        clearTimeout(this.timerId);
        this.timerId = undefined;
    }
    carouselStateSubscribe() {
        this.carouselService.carouselIndex$
            .pipe(takeUntilDestroyed(this.#destroyRef))
            .subscribe((nextItem) => {
            if ('active' in nextItem) {
                this.itemChange.emit(nextItem.active);
            }
            this.activeItemInterval = typeof nextItem.interval === 'number' && nextItem.interval > -1 ? nextItem.interval : this.interval;
            const isLastItem = ((nextItem.active === nextItem.lastItemIndex) && this.direction === 'next') || ((nextItem.active === 0) && this.direction === 'prev');
            !this.wrap && isLastItem ? this.resetTimer() : this.setTimer();
        });
    }
    intersectionServiceSubscribe() {
        this.intersectionService.createIntersectionObserver(this.hostElement);
        this.intersectionService.intersecting$
            .pipe(filter(next => next.hostElement === this.hostElement), finalize(() => {
            this.intersectionService.unobserve(this.hostElement);
        }), takeUntilDestroyed(this.#destroyRef))
            .subscribe(next => {
            this.visible = next.isIntersecting;
            next.isIntersecting ? this.setTimer() : this.resetTimer();
        });
    }
    swipeSubscribe(subscribe = true) {
        if (this.touch && subscribe) {
            const carouselElement = this.hostElement.nativeElement;
            const touchStart$ = fromEvent(carouselElement, 'touchstart');
            const touchEnd$ = fromEvent(carouselElement, 'touchend');
            const touchMove$ = fromEvent(carouselElement, 'touchmove');
            this.swipeSubscription = touchStart$.pipe(zipWith(touchEnd$.pipe(withLatestFrom(touchMove$))), takeUntilDestroyed(this.#destroyRef))
                .subscribe(([touchstart, [touchend, touchmove]]) => {
                touchstart.stopPropagation();
                touchmove.stopPropagation();
                const distanceX = touchstart.touches[0].clientX - touchmove.touches[0].clientX;
                if (Math.abs(distanceX) > 0.3 * carouselElement.clientWidth && touchstart.timeStamp <= touchmove.timeStamp) {
                    const nextIndex = this.carouselState.direction(distanceX > 0 ? 'next' : 'prev');
                    this.carouselState.state = { activeItemIndex: nextIndex };
                }
            });
        }
        else {
            this.swipeSubscription?.unsubscribe();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: CarouselComponent, deps: [{ token: CarouselConfig }, { token: i0.ElementRef }, { token: i1.CarouselService }, { token: i2.CarouselState }, { token: i3.IntersectionService }, { token: i3.ListenersService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.12", type: CarouselComponent, isStandalone: true, selector: "c-carousel", inputs: { activeIndex: "activeIndex", animate: "animate", direction: "direction", interval: "interval", pause: "pause", touch: "touch", transition: "transition", wrap: "wrap" }, outputs: { itemChange: "itemChange" }, host: { properties: { "class": "this.hostClasses" } }, providers: [CarouselService, CarouselState, CarouselConfig, ListenersService], hostDirectives: [{ directive: i4.ThemeDirective, inputs: ["dark", "dark"] }], ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: CarouselComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-carousel', template: '<ng-content />', providers: [CarouselService, CarouselState, CarouselConfig, ListenersService], standalone: true, hostDirectives: [
                        { directive: ThemeDirective, inputs: ['dark'] }
                    ], styles: [":host{display:block}\n"] }]
        }], ctorParameters: () => [{ type: i5.CarouselConfig, decorators: [{
                    type: Inject,
                    args: [CarouselConfig]
                }] }, { type: i0.ElementRef }, { type: i1.CarouselService }, { type: i2.CarouselState }, { type: i3.IntersectionService }, { type: i3.ListenersService }], propDecorators: { activeIndex: [{
                type: Input
            }], animate: [{
                type: Input
            }], direction: [{
                type: Input
            }], interval: [{
                type: Input
            }], pause: [{
                type: Input
            }], touch: [{
                type: Input
            }], transition: [{
                type: Input
            }], wrap: [{
                type: Input
            }], itemChange: [{
                type: Output
            }], hostClasses: [{
                type: HostBinding,
                args: ['class']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2Fyb3VzZWwuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvY29yZXVpLWFuZ3VsYXIvc3JjL2xpYi9jYXJvdXNlbC9jYXJvdXNlbC9jYXJvdXNlbC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUVMLFNBQVMsRUFDVCxVQUFVLEVBRVYsWUFBWSxFQUNaLFdBQVcsRUFDWCxNQUFNLEVBQ04sTUFBTSxFQUNOLEtBQUssRUFHTCxNQUFNLEVBQ1AsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDaEUsT0FBTyxFQUFFLFNBQVMsRUFBZ0IsTUFBTSxNQUFNLENBQUM7QUFDL0MsT0FBTyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsY0FBYyxFQUFFLE9BQU8sRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRzNFLE9BQU8sRUFBb0IsZ0JBQWdCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUdwRSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFDOUQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ2xELE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUN0RCxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sb0JBQW9CLENBQUM7Ozs7Ozs7QUFZcEQsTUFBTSxPQUFPLGlCQUFpQjtJQUM1QixZQUNrQyxNQUFzQixFQUM5QyxXQUF1QixFQUN2QixlQUFnQyxFQUNoQyxhQUE0QixFQUM1QixtQkFBd0MsRUFDeEMsZ0JBQWtDO1FBTFYsV0FBTSxHQUFOLE1BQU0sQ0FBZ0I7UUFDOUMsZ0JBQVcsR0FBWCxXQUFXLENBQVk7UUFDdkIsb0JBQWUsR0FBZixlQUFlLENBQWlCO1FBQ2hDLGtCQUFhLEdBQWIsYUFBYSxDQUFlO1FBQzVCLHdC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a0JBRWxCLGNBQWM7bUdBRmIsaUJBQWlCLHlVQU5qQixDQUFDLGVBQWUsRUFBRSxhQUFhLEVBQUUsY0FBYyxFQUFFLGdCQUFnQixDQUFDLHdHQUZuRSxnQkFBZ0I7OzRGQVFmLGlCQUFpQjtrQkFWN0IsU0FBUzsrQkFDRSxZQUFZLFlBQ1osZ0JBQWdCLGFBRWYsQ0FBQyxlQUFlLEVBQUUsYUFBYSxFQUFFLGNBQWMsRUFBRSxnQkFBZ0IsQ0FBQyxjQUNqRSxJQUFJLGtCQUNBO3dCQUNkLEVBQUUsU0FBUyxFQUFFLGNBQWMsRUFBRSxNQUFNLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRTtxQkFDaEQ7OzBCQUlFLE1BQU07MkJBQUMsY0FBYzs2TEFjZixXQUFXO3NCQUFuQixLQUFLO2dCQUtHLE9BQU87c0JBQWYsS0FBSztnQkFLRyxTQUFTO3NCQUFqQixLQUFLO2dCQU1HLFFBQVE7c0JBQWhCLEtBQUs7Z0JBS0csS0FBSztzQkFBYixLQUFLO2dCQU1HLEtBQUs7c0JBQWIsS0FBSztnQkFNRyxVQUFVO3NCQUFsQixLQUFLO2dCQU1HLElBQUk7c0JBQVosS0FBSztnQkFLSSxVQUFVO3NCQUFuQixNQUFNO2dCQUdILFdBQVc7c0JBRGQsV0FBVzt1QkFBQyxPQUFPIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgQ29tcG9uZW50LFxuICBEZXN0cm95UmVmLFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIEhvc3RCaW5kaW5nLFxuICBpbmplY3QsXG4gIEluamVjdCxcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPdXRwdXRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyB0YWtlVW50aWxEZXN0cm95ZWQgfSBmcm9tICdAYW5ndWxhci9jb3JlL3J4anMtaW50ZXJvcCc7XG5pbXBvcnQgeyBmcm9tRXZlbnQsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZmlsdGVyLCBmaW5hbGl6ZSwgd2l0aExhdGVzdEZyb20sIHppcFdpdGggfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IEludGVyc2VjdGlvblNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcyc7XG5pbXBvcnQgeyBJTGlzdGVuZXJzQ29uZmlnLCBMaXN0ZW5lcnNTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMnO1xuXG5pbXBvcnQgeyBUcmlnZ2VycyB9IGZyb20gJy4uLy4uL2NvcmV1aS50eXBlcyc7XG5pbXBvcnQgeyBUaGVtZURpcmVjdGl2ZSB9IGZyb20gJy4uLy4uL3NoYXJlZC90aGVtZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgQ2Fyb3VzZWxTdGF0ZSB9IGZyb20gJy4uL2Nhcm91c2VsLXN0YXRlJztcbmltcG9ydCB7IENhcm91c2VsU2VydmljZSB9IGZyb20gJy4uL2Nhcm91c2VsLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2Fyb3VzZWxDb25maWcgfSBmcm9tICcuLi9jYXJvdXNlbC5jb25maWcnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjLWNhcm91c2VsJyxcbiAgdGVtcGxhdGU6ICc8bmctY29udGVudCAvPicsXG4gIHN0eWxlVXJsczogWycuL2Nhcm91c2VsLmNvbXBvbmVudC5zY3NzJ10sXG4gIHByb3ZpZGVyczogW0Nhcm91c2VsU2VydmljZSwgQ2Fyb3VzZWxTdGF0ZSwgQ2Fyb3VzZWxDb25maWcsIExpc3RlbmVyc1NlcnZpY2VdLFxuICBzdGFuZGFsb25lOiB0cnVlLFxuICBob3N0RGlyZWN0aXZlczogW1xuICAgIHsgZGlyZWN0aXZlOiBUaGVtZURpcmVjdGl2ZSwgaW5wdXRzOiBbJ2RhcmsnXSB9XG4gIF1cbn0pXG5leHBvcnQgY2xhc3MgQ2Fyb3VzZWxDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSwgQWZ0ZXJDb250ZW50SW5pdCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIEBJbmplY3QoQ2Fyb3VzZWxDb25maWcpIHByaXZhdGUgY29uZmlnOiBDYXJvdXNlbENvbmZpZyxcbiAgICBwcml2YXRlIGhvc3RFbGVtZW50OiBFbGVtZW50UmVmLFxuICAgIHByaXZhdGUgY2Fyb3VzZWxTZXJ2aWNlOiBDYXJvdXNlbFNlcnZpY2UsXG4gICAgcHJpdmF0ZSBjYXJvdXNlbFN0YXRlOiBDYXJvdXNlbFN0YXRlLFxuICAgIHByaXZhdGUgaW50ZXJzZWN0aW9uU2VydmljZTogSW50ZXJzZWN0aW9uU2VydmljZSxcbiAgICBwcml2YXRlIGxpc3RlbmVyc1NlcnZpY2U6IExpc3RlbmVyc1NlcnZpY2VcbiAgKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjb25maWcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGV4IG9mIHRoZSBhY3RpdmUgaXRlbS5cbiAgICogQHR5cGUgbnVtYmVyXG4gICAqL1xuICBASW5wdXQoKSBhY3RpdmVJbmRleDogbnVtYmVyID0gMDtcbiAgLyoqXG4gICAqIENhcm91c2VsIGF1dG9tYXRpY2FsbHkgc3RhcnRzIGN5Y2xlIGl0ZW1zLlxuICAgKiBAdHlwZSBib29sZWFuXG4gICAqL1xuICBASW5wdXQoKSBhbmltYXRlOiBib29sZWFuID0gdHJ1ZTtcbiAgLyoqXG4gICAqIENhcm91c2VsIGRpcmVjdGlvbi4gW2RvY3NdXG4gICAqIEB0eXBlIHsnbmV4dCcgfCAncHJldid9XG4gICAqL1xuICBASW5wdXQoKSBkaXJlY3Rpb246ICduZXh0JyB8ICdwcmV2JyA9ICduZXh0JztcbiAgLyoqXG4gICAqIFRoZSBhbW91bnQgb2YgdGltZSB0byBkZWxheSBiZXR3ZWVuIGF1dG9tYXRpY2FsbHkgY3ljbGluZyBhbiBpdGVtLiBJZiBmYWxzZSwgY2Fyb3VzZWwgd2lsbCBub3QgYXV0b21hdGljYWxseSBjeWNsZS5cbiAgICogQHR5cGUgbnVtYmVyXG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIEBJbnB1dCgpIGludGVydmFsOiBudW1iZXIgPSAwO1xuICAvKipcbiAgICogU2V0cyB3aGljaCBldmVudCBoYW5kbGVycyB5b3XigJlkIGxpa2UgcHJvdmlkZWQgdG8geW91ciBwYXVzZSBwcm9wLiBZb3UgY2FuIHNwZWNpZnkgb25lIHRyaWdnZXIgb3IgYW4gYXJyYXkgb2YgdGhlbS5cbiAgICogQHR5cGUgeydob3ZlcicgfCAnZm9jdXMnIHwgJ2NsaWNrJ31cbiAgICovXG4gIEBJbnB1dCgpIHBhdXNlOiBUcmlnZ2VycyB8IFRyaWdnZXJzW10gfCBmYWxzZSA9ICdob3Zlcic7XG4gIC8qKlxuICAgKiBTdXBwb3J0IGxlZnQvcmlnaHQgc3dpcGUgaW50ZXJhY3Rpb25zIG9uIHRvdWNoc2NyZWVuIGRldmljZXMuXG4gICAqIEB0eXBlIGJvb2xlYW5cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgQElucHV0KCkgdG91Y2g6IGJvb2xlYW4gPSB0cnVlO1xuICAvKipcbiAgICogU2V0IHR5cGUgb2YgdGhlIHRyYW5zaXRpb24uXG4gICAqIEB0eXBlIHsnc2xpZGUnIHwgJ2Nyb3NzZmFkZSd9XG4gICAqIEBkZWZhdWx0ICdzbGlkZSdcbiAgICovXG4gIEBJbnB1dCgpIHRyYW5zaXRpb246ICdzbGlkZScgfCAnY3Jvc3NmYWRlJyA9ICdzbGlkZSc7XG4gIC8qKlxuICAgKiBTZXQgd2hldGhlciB0aGUgY2Fyb3VzZWwgc2hvdWxkIGN5Y2xlIGNvbnRpbnVvdXNseSBvciBoYXZlIGhhcmQgc3RvcHMuXG4gICAqIEB0eXBlIGJvb2xlYW5cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgQElucHV0KCkgd3JhcDogYm9vbGVhbiA9IHRydWU7XG4gIC8qKlxuICAgKiBFdmVudCBlbWl0dGVkIG9uIGNhcm91c2VsIGl0ZW0gY2hhbmdlLiBbZG9jc11cbiAgICogQHR5cGUgbnVtYmVyXG4gICAqL1xuICBAT3V0cHV0KCkgaXRlbUNoYW5nZTogRXZlbnRFbWl0dGVyPG51bWJlcj4gPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcblxuICBASG9zdEJpbmRpbmcoJ2NsYXNzJylcbiAgZ2V0IGhvc3RDbGFzc2VzKCk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhcm91c2VsOiB0cnVlLFxuICAgICAgc2xpZGU6IHRydWUsXG4gICAgICAnY2Fyb3VzZWwtZmFkZSc6IHRoaXMudHJhbnNpdGlvbiA9PT0gJ2Nyb3NzZmFkZSdcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSB0aW1lcklkOiBSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0PiB8IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSBhY3RpdmVJdGVtSW50ZXJ2YWwgPSAwO1xuICBwcml2YXRlIHN3aXBlU3Vic2NyaXB0aW9uPzogU3Vic2NyaXB0aW9uO1xuICByZWFkb25seSAjZGVzdHJveVJlZiA9IGluamVjdChEZXN0cm95UmVmKTtcblxuICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLmNhcm91c2VsU3RhdGVTdWJzY3JpYmUoKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMucmVzZXRUaW1lcigpO1xuICAgIHRoaXMuY2xlYXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnN3aXBlU3Vic2NyaWJlKGZhbHNlKTtcbiAgfVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLmludGVyc2VjdGlvblNlcnZpY2VTdWJzY3JpYmUoKTtcbiAgICB0aGlzLmNhcm91c2VsU3RhdGUuc3RhdGUgPSB7IGFjdGl2ZUl0ZW1JbmRleDogdGhpcy5hY3RpdmVJbmRleCwgYW5pbWF0ZTogdGhpcy5hbmltYXRlIH07XG4gICAgdGhpcy5zZXRMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnN3aXBlU3Vic2NyaWJlKCk7XG4gIH1cblxuICBwcml2YXRlIHNldExpc3RlbmVycygpOiB2b2lkIHtcbiAgICBjb25zdCBjb25maWc6IElMaXN0ZW5lcnNDb25maWcgPSB7XG4gICAgICBob3N0RWxlbWVudDogdGhpcy5ob3N0RWxlbWVudCxcbiAgICAgIHRyaWdnZXI6IHRoaXMucGF1c2UgfHwgW10sXG4gICAgICBjYWxsYmFja09mZjogKCkgPT4ge1xuICAgICAgICB0aGlzLnNldFRpbWVyKCk7XG4gICAgICB9LFxuICAgICAgY2FsbGJhY2tPbjogKCkgPT4ge1xuICAgICAgICB0aGlzLnJlc2V0VGltZXIoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMubGlzdGVuZXJzU2VydmljZS5zZXRMaXN0ZW5lcnMoY29uZmlnKTtcbiAgfVxuXG4gIHByaXZhdGUgY2xlYXJMaXN0ZW5lcnMoKTogdm9pZCB7XG4gICAgdGhpcy5saXN0ZW5lcnNTZXJ2aWNlLmNsZWFyTGlzdGVuZXJzKCk7XG4gIH1cblxuICBzZXQgdmlzaWJsZSh2YWx1ZSkge1xuICAgIHRoaXMuX3Zpc2libGUgPSB2YWx1ZTtcbiAgfVxuXG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICB9XG5cbiAgcHJpdmF0ZSBfdmlzaWJsZTogYm9vbGVhbiA9IHRydWU7XG5cbiAgc2V0VGltZXIoKTogdm9pZCB7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSB0aGlzLmFjdGl2ZUl0ZW1JbnRlcnZhbCB8fCAwO1xuICAgIHRoaXMucmVzZXRUaW1lcigpO1xuICAgIGlmIChpbnRlcnZhbCA+IDApIHtcbiAgICAgIHRoaXMudGltZXJJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCBuZXh0SW5kZXggPSB0aGlzLmNhcm91c2VsU3RhdGUuZGlyZWN0aW9uKHRoaXMuZGlyZWN0aW9uKTtcbiAgICAgICAgdGhpcy5jYXJvdXNlbFN0YXRlLnN0YXRlID0geyBhY3RpdmVJdGVtSW5kZXg6IG5leHRJbmRleCB9O1xuICAgICAgfSwgaW50ZXJ2YWwpO1xuICAgIH1cbiAgfVxuXG4gIHJlc2V0VGltZXIoKTogdm9pZCB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJJZCk7XG4gICAgdGhpcy50aW1lcklkID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgcHJpdmF0ZSBjYXJvdXNlbFN0YXRlU3Vic2NyaWJlKCk6IHZvaWQge1xuICAgIHRoaXMuY2Fyb3VzZWxTZXJ2aWNlLmNhcm91c2VsSW5kZXgkXG4gICAgICAucGlwZShcbiAgICAgICAgdGFrZVVudGlsRGVzdHJveWVkKHRoaXMuI2Rlc3Ryb3lSZWYpXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKChuZXh0SXRlbSkgPT4ge1xuICAgICAgICBpZiAoJ2FjdGl2ZScgaW4gbmV4dEl0ZW0pIHtcbiAgICAgICAgICB0aGlzLml0ZW1DaGFuZ2UuZW1pdChuZXh0SXRlbS5hY3RpdmUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlSXRlbUludGVydmFsID0gdHlwZW9mIG5leHRJdGVtLmludGVydmFsID09PSAnbnVtYmVyJyAmJiBuZXh0SXRlbS5pbnRlcnZhbCA+IC0xID8gbmV4dEl0ZW0uaW50ZXJ2YWwgOiB0aGlzLmludGVydmFsO1xuICAgICAgICBjb25zdCBpc0xhc3RJdGVtID0gKChuZXh0SXRlbS5hY3RpdmUgPT09IG5leHRJdGVtLmxhc3RJdGVtSW5kZXgpICYmIHRoaXMuZGlyZWN0aW9uID09PSAnbmV4dCcpIHx8ICgobmV4dEl0ZW0uYWN0aXZlID09PSAwKSAmJiB0aGlzLmRpcmVjdGlvbiA9PT0gJ3ByZXYnKTtcbiAgICAgICAgIXRoaXMud3JhcCAmJiBpc0xhc3RJdGVtID8gdGhpcy5yZXNldFRpbWVyKCkgOiB0aGlzLnNldFRpbWVyKCk7XG4gICAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgaW50ZXJzZWN0aW9uU2VydmljZVN1YnNjcmliZSgpOiB2b2lkIHtcbiAgICB0aGlzLmludGVyc2VjdGlvblNlcnZpY2UuY3JlYXRlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIodGhpcy5ob3N0RWxlbWVudCk7XG4gICAgdGhpcy5pbnRlcnNlY3Rpb25TZXJ2aWNlLmludGVyc2VjdGluZyRcbiAgICAgIC5waXBlKFxuICAgICAgICBmaWx0ZXIobmV4dCA9PiBuZXh0Lmhvc3RFbGVtZW50ID09PSB0aGlzLmhvc3RFbGVtZW50KSxcbiAgICAgICAgZmluYWxpemUoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uU2VydmljZS51bm9ic2VydmUodGhpcy5ob3N0RWxlbWVudCk7XG4gICAgICAgIH0pLFxuICAgICAgICB0YWtlVW50aWxEZXN0cm95ZWQodGhpcy4jZGVzdHJveVJlZilcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUobmV4dCA9PiB7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IG5leHQuaXNJbnRlcnNlY3Rpbmc7XG4gICAgICAgIG5leHQuaXNJbnRlcnNlY3RpbmcgPyB0aGlzLnNldFRpbWVyKCkgOiB0aGlzLnJlc2V0VGltZXIoKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBzd2lwZVN1YnNjcmliZShzdWJzY3JpYmU6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XG4gICAgaWYgKHRoaXMudG91Y2ggJiYgc3Vic2NyaWJlKSB7XG4gICAgICBjb25zdCBjYXJvdXNlbEVsZW1lbnQgPSB0aGlzLmhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICBjb25zdCB0b3VjaFN0YXJ0JCA9IGZyb21FdmVudDxUb3VjaEV2ZW50PihjYXJvdXNlbEVsZW1lbnQsICd0b3VjaHN0YXJ0Jyk7XG4gICAgICBjb25zdCB0b3VjaEVuZCQgPSBmcm9tRXZlbnQ8VG91Y2hFdmVudD4oY2Fyb3VzZWxFbGVtZW50LCAndG91Y2hlbmQnKTtcbiAgICAgIGNvbnN0IHRvdWNoTW92ZSQgPSBmcm9tRXZlbnQ8VG91Y2hFdmVudD4oY2Fyb3VzZWxFbGVtZW50LCAndG91Y2htb3ZlJyk7XG4gICAgICB0aGlzLnN3aXBlU3Vic2NyaXB0aW9uID0gdG91Y2hTdGFydCQucGlwZShcbiAgICAgICAgemlwV2l0aCh0b3VjaEVuZCQucGlwZSh3aXRoTGF0ZXN0RnJvbSh0b3VjaE1vdmUkKSkpLFxuICAgICAgICB0YWtlVW50aWxEZXN0cm95ZWQodGhpcy4jZGVzdHJveVJlZilcbiAgICAgIClcbiAgICAgICAgLnN1YnNjcmliZSgoW3RvdWNoc3RhcnQsIFt0b3VjaGVuZCwgdG91Y2htb3ZlXV0pID0+IHtcbiAgICAgICAgICB0b3VjaHN0YXJ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIHRvdWNobW92ZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBjb25zdCBkaXN0YW5jZVggPSB0b3VjaHN0YXJ0LnRvdWNoZXNbMF0uY2xpZW50WCAtIHRvdWNobW92ZS50b3VjaGVzWzBdLmNsaWVudFg7XG4gICAgICAgICAgaWYgKE1hdGguYWJzKGRpc3RhbmNlWCkgPiAwLjMgKiBjYXJvdXNlbEVsZW1lbnQuY2xpZW50V2lkdGggJiYgdG91Y2hzdGFydC50aW1lU3RhbXAgPD0gdG91Y2htb3ZlLnRpbWVTdGFtcCkge1xuICAgICAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gdGhpcy5jYXJvdXNlbFN0YXRlLmRpcmVjdGlvbihkaXN0YW5jZVggPiAwID8gJ25leHQnIDogJ3ByZXYnKTtcbiAgICAgICAgICAgIHRoaXMuY2Fyb3VzZWxTdGF0ZS5zdGF0ZSA9IHsgYWN0aXZlSXRlbUluZGV4OiBuZXh0SW5kZXggfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN3aXBlU3Vic2NyaXB0aW9uPy51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxufVxuIl19